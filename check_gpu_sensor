#!/usr/bin/perl
# check_gpu_sensor: Nagios/Icinga plugin to check GPU sensors
#
# Copyright (C) 2011-2012 Thomas-Krenn.AG,
# For a list of contributors see changelog.txt
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3 of the License, or (at your option) any later
# version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License along with
# this program; if not, see <http://www.gnu.org/licenses/>.
#
################################################################################
# The following guides provide helpful information if you want to extend this
# script:
#  http://nagiosplug.sourceforge.net/developer-guidelines.html (plug-in
#  development guidelines)
################################################################################

use strict;
use warnings;
use nvidia::ml qw(:all);
use Getopt::Long qw(:config no_ignore_case);#case sensitive
use Switch;
###############################################
# Global Variables in the current scope
###############################################
our $EXIT_CODE = 0; #Exit value of plugin
our $LASTERRORSTRING = ''; #Error messages of functions
our @DEVICE_LIST = (); #Array of GPUs in current system
our @PERF_DATA = (); #Array of perf-data for GPU

#hash keys we don't want to have in PERF_DATA
our %EXCLUDE_LIST = (
	deviceHandle => '1',
	deviceID => '1',
	devicePCIBusID => '1',
	nvmlDevicePciInfo => '1',
	nvmlDeviceComputeMode => '1',
	PWRMgmtMode => '1',
	OEMInforom => '1',
	ECCInforom => '1',
	PWRInforom => '1',
	pendingECCMode => '1',
	currentECCMode => '1',
	ECCMemAggDble => '1',
	ECCL1AggDble => '1',
	ECCL2AggDble => '1',
	ECCRegAggDble => '1',
	ECCTexAggDble => '1',
	persistenceMode => '1',
	inforomValid => '1'
);

#warning and critical default threshold levels
our %PERF_THRESHOLDS = (
	nvmlGpuTemperature => ['85','100'], #Temperature
	nvmlUsedMemory => ['95','99'], #Memory utilizaion
	nvmlDeviceFanSpeed => ['80','95'], #Fan speed
	#only single ecc errors are configurable
	#double ecc errors are treated as discrete sensors and issue
	#a critical status
	ECCMemAggSgl => ['1','2'], #Dev memory ecc errors
	ECCL1AggSgl => ['1','2'], #L1 cache ecc errors
	ECCL2AggSgl => ['1','2'], #L2 cache ecc errors
	ECCRegAggSgl => ['1','2'], #Dev register ecc errors
	ECCTexAggSgl => ['1','2'], #Dev texture cache ecc errors
	PWRUsage => ['150','200'],
	#device utilization rates
	gpuUtil => ['90','100'],
	memUtil => ['90','100'],
);

###############################################
# Plugin specific functions
# They return help messages and version information
###############################################
sub get_version{
	if(get_driver_version() eq "NOK"){
		print "Error while fetching nvidia driver version: $LASTERRORSTRING\n";
		exit(3);		
	}
	return "check_gpu_sensor version 1.2 20120912
Copyright (C) 2011-2012 Thomas-Krenn.AG (written by Georg Sch√∂nberger)
Current updates available via git repository git.thomas-krenn.com.
Your system is using NVIDIA driver version ".get_driver_version()." with
NVML version ".get_nvml_version();
}
sub get_usage{
	return "Usage:
check_gpu_sensor -db <pci bus string> | -d <device id> | [-T <sensor type>] [-w <list of warn levels>]
[-c <list of crit levels>] [-v|-vv|-vvv] [-h] [-V] [--show-na]"
}
sub get_help{
	return "

  [-d <device id>]
        Return information about the GPU with the given device ID. IDs
        can be checked with the nvidia-smi tool. Attention: It is not
        ensured that device IDs are persistent across reboots. The safest
        way is to define a device bus string via '-db' which can be found out
        with nvidia-smi.
  [-db <pci bus string>]
        Check the GPU with the corresponding pci bus device string. The pci bus
        ID can be found out with:
        nvidia-smi -a |grep 'Bus Id'.
        An example string is '0000:01:00.0' that can be used to call the plugin:
            ./check_gpu_sensor -db '0000:01:00.0'
  [-T <sensor type>]
       limit sensors to query based on NVML sensor types.
       The sensors are currently only working for performance data sensors.
       Examples for GPU sensor types are 'nvmlGpuTemperature',
       'nvmlUsedMemory','nvmlDeviceFanSpeed'
       
  [-w <list of warning thresholds>]
       Change the default warning levels. The order of the levels
       is the following:
       -nvmlGpuTemperature
       -nvmlUsedMemory
       -nvmlDeviceFanSpeed
       -ECCMemAggSgl
       -ECCL1AggSgl
       -ECCL2AggSgl
       -ECCRegAggSgl
       -ECCTexAggSgl
       -PWRUsage
       -gpuUtil
       -memUtil
       Levels that should stay default get a 'd' assigned.
       Example:
           check_gpu_sensor -w '75,d,d,d,d,d,d,d,d,d,d' 
       This changes the warning level for the temperature.
  [-c <list of critical thresholds>]
       Change the default critical levels. The order of the levels
       is the same as for the warning levels.
       Levels that should stay default get a 'd' assigned.
       Example:
           check_gpu_sensor -c '100,d,d,d,d,d,d,d,d,d,d' 
       This changes the critical level for the temperature.  		
  [-v <Verbose Level>]
       be verbose
         (no -v) .. single line output
         -v ..... single line output with additional details for warnings
         -vv ..... multi line output, also with additional details for warnings
         -vvv ..... normal output, then debugging output, followed by normal multi line output
  [-h]
       show this help
  [-V]
       show version information
  [--show-na]
       show sensors with value equal to N/A (means not available)";
}


sub check_nvml_setup{
	#TODO Check for locations of nvml library
	my $return = '';
	if(!(-e "/usr/lib32/libnvidia-ml.so") &&
		!(-e "/usr/lib32/nvidia-current/libnvidia-ml.so") &&
		!(-e "/usr/lib/nvidia-current/libnvidia-ml.so") &&
		!(-e "/usr/lib/libnvidia-ml.so")){
		$LASTERRORSTRING = "Nvml library not found on system";
		return "NOK";
	}
	else{
		return "OK";
	}
}
###############################################
# Helper functions 
# They check for errors and print several structs
# They also generate status outputs and verbose information
###############################################

# Checking for errors returned by the nvml library
# If a functionality is not supported "N/A" is returned
sub handle_error{
	my $return = $_[0];
	my $value = $_[1];
	my $is_hash = $_[2];
	if($return == $NVML_SUCCESS){
		return $value;	
	}
	else{
		if($return == $NVML_ERROR_NOT_SUPPORTED){
			return 'N/A';	
		}
		else{
			return nvmlErrorString($return);
		}
	}	
}
#Prints all values of a given hash
#If every value of the hash is N/A, the string
#N/A is returned
sub print_hash{
	my $hash_ref = shift;
	my $show_na = shift;
	my $string = "";
	my $is_na = 1;
	
	foreach my $k (keys %{$hash_ref}) {
		if($hash_ref->{$k} ne 'N/A'){
			$is_na = 0;
		}
		#only print N/A sensors if show all is given
		if(!(defined $show_na) && $hash_ref->{$k} eq 'N/A'){
			next;
		}
		if(ref($hash_ref->{$k}) eq "SCALAR"){
			$string .= "\t$k: $$hash_ref->{$k}\n";
		}
		else{
			$string .= "\t$k: $hash_ref->{$k}\n";	
		}		
	}
	#if all values are N/A, return this
	if($is_na){
		return 'N/A';
	}
	else{
		return $string;
	}
}
#Print the value of the status hash
sub get_hash_values{
	my $hash_ref = shift;#reference to device hash
	my $show_na = shift;
	my $string = "";
	my $is_na = 1;
	
	foreach my $k (keys %{$hash_ref}) {
		if($k eq "deviceHandle"){
			next;#we don't want to print driver handles
		}
		#only print N/A sensors if show all is given
		if(!(defined $show_na) && $hash_ref->{$k} eq 'N/A'){
			next;
		}
		#if we found a hash, call the print_hash function
		#if all values of a hash are N/A, the hash itself gets
		#the string N/A assigned
		if(ref($hash_ref->{$k}) eq 'HASH'){
				my $hash_string = print_hash($hash_ref->{$k},$show_na);
				if($hash_string eq 'N/A'){
					if(defined $show_na){
						$string .= "-$k: $hash_string\n";
					}
				}
				else{
					$string .= "-$k\n";
					$string .= $hash_string;
				}
		}
		elsif(ref($hash_ref->{$k}) eq 'SCALAR'){
			$string .= "-$k: $$hash_ref->{$k}\n";
		}
		else{
			$string .= "-$k: $hash_ref->{$k}\n";	
		}
	}
	return $string;
	
}
#Form a status string with warning, crit sensor values
#or performance data followed by their thresholds
sub get_status_string{
	my $level = shift;
	my $curr_sensors = shift;
	my $verbosity = shift;
	my $status_string = "";

	if($level ne "Warning" && $level ne "Critical"
		&& $level ne "Performance"){
		return;
	}
	if($level eq "Warning"){
		$curr_sensors = $curr_sensors->[1];
	}
	if($level eq "Critical"){
		$curr_sensors = $curr_sensors->[2];
	}
	my $i = 1;
	#Collect performance data of warn and crit sensors
	if($level eq "Warning" || $level eq "Critical"){
		if(@$curr_sensors){
			foreach my $sensor (@$curr_sensors){
				$status_string .= "[".$sensor." = ".$level;
				if($verbosity && exists $PERF_DATA[0]->{$sensor}){
					$status_string .= " (".$PERF_DATA[0]->{$sensor}.")";	
				}
				$status_string .= "]";
				if($i != @$curr_sensors){
					$status_string .= " ";#print a space except at the end
				}
				$i++;
			}
		}
	}
	#Collect performance values followed by thresholds
	if($level eq "Performance"){
		foreach my $k (keys %$curr_sensors){
			$status_string .= $k."=".$curr_sensors->{$k};
			#print warn and crit thresholds
			if(exists $PERF_THRESHOLDS{$k}){
				$status_string .= ";".$PERF_THRESHOLDS{$k}[0];
				$status_string .= ";".$PERF_THRESHOLDS{$k}[1].";";
			}
			if($i != (keys %$curr_sensors)){
				$status_string .= " ";
			}
			$i++;
		}	
	}
	return $status_string;
}
sub get_verbose_string{
	my $verbosity = shift;
	my $device = shift;
	my $show_na = shift;
	my $status_string = "";
	
	if($verbosity == 3){
		$status_string .= "------------- begin of debug output (-vvv is set): ------------\n";
		$status_string .= "Nvidia Driver Version: ".get_driver_version()."\n";
		$status_string .= "Number of GPUs in system: ".@DEVICE_LIST."\n";
		foreach my $g (@DEVICE_LIST){
			$status_string .= "\t-".$g->{'productName'}."\n";
		}
		$status_string .= "----Called sensors (incl. N/A)----\n";
		$status_string .= get_hash_values($device,1);
	}
	if($verbosity == 3){
		$status_string .= "------------- end of debug output ------------\n";
	}
	if($verbosity == 2 || $verbosity == 3){
		$status_string .= get_hash_values($device,$show_na)
	}
	return $status_string;
}

#Check a hash for performance data
sub check_hash_for_perf{
	my $hash_ref = shift;
	my $perf_data_ref = shift;
	my @sensor_list = @{(shift)};
	my %hash = %$hash_ref;
		
	if(exists $hash{'Error'}){
		print "Status: ".$hash{'Error'}."\n";
		return;
	}	
	foreach my $k (@sensor_list) {
		#we don't want to print values present in exclude list
		if(exists $EXCLUDE_LIST{$k}){
			next;
		}
		if(ref($hash{$k}) eq 'HASH'){
			#the param sensor_list is switched to the hash keys for the next call of check_hash
			my @key_list = keys %{$hash{$k}};
			$perf_data_ref = check_hash_for_perf($hash{$k},$perf_data_ref,\@key_list);
		}
		elsif(ref($hash{$k}) eq 'SCALAR'){
			#found a ref to a numeric value
			#deref it and push it to hash
			$perf_data_ref->{$k} = ${$hash{$k}};
		}
		#integer
		elsif($hash{$k} =~ /^[+-]?[0-9]+$/){
			$perf_data_ref->{$k} = $hash{$k};
		}
		#float
		elsif ($hash{$k} =~ /^[-+]?[0-9]*\.?[0-9]+$/ ){
				$perf_data_ref->{$k} = sprintf("%.2f", $hash{$k});
		}
	}
	return $perf_data_ref;
}

###############################################
# System specific functions 
# They are used to collect information about the current system
###############################################
sub get_nvml_version{
	#Working since 3.295.41
	my $version = get_driver_version();
	$version =~ /(\d+)\.(\d+)/;
	if($1 >= 295){
		my ($return, $version) = nvmlSystemGetNVMLVersion();
		if($return == $NVML_SUCCESS){
			return $version;
		}
	}
	else{
		return "not yet supported";
	}	
}
sub get_driver_version{
	my ($return, $version) = nvmlSystemGetDriverVersion();
	if($return == $NVML_SUCCESS){
		return $version;
	}
	else{
		$LASTERRORSTRING = nvmlErrorString($return);
		return "NOK";
	}	
}
sub get_device_count{
	my ($return, $count) = nvmlDeviceGetCount();
	if($return == $NVML_SUCCESS){
		return $count;
	}
	else{
		$LASTERRORSTRING = nvmlErrorString($return);
		return "NOK";
	}
}
###############################################
# Device specific functions 
# They are used to query parameters from a device
###############################################
sub get_device_clock{
	my %current_device = %{(shift)};
	my %clock_hash;
	my ($return,$value) = nvmlDeviceGetClockInfo($current_device{'deviceHandle'},$NVML_CLOCK_GRAPHICS);
	$clock_hash{'graphicsClock'} = handle_error($return,$value);
	
	($return,$value) = nvmlDeviceGetClockInfo($current_device{'deviceHandle'},$NVML_CLOCK_SM);
	$clock_hash{'SMClock'} = handle_error($return,$value);
	
	($return,$value) = nvmlDeviceGetClockInfo($current_device{'deviceHandle'},$NVML_CLOCK_MEM);
	$clock_hash{'memClock'} = handle_error($return,$value);
	
	return \%clock_hash;
}
sub get_device_inforom{
	my %current_device = %{(shift)};
	my %inforom_hash;
	my ($return,$value) = nvmlDeviceGetInforomVersion($current_device{'deviceHandle'},$NVML_INFOROM_OEM);
	$inforom_hash{'OEMInforom'} = handle_error($return,$value);
	
	($return,$value) = nvmlDeviceGetInforomVersion($current_device{'deviceHandle'},$NVML_INFOROM_ECC);
	$inforom_hash{'ECCInforom'} = handle_error($return,$value);
	
	($return,$value) = nvmlDeviceGetInforomVersion($current_device{'deviceHandle'},$NVML_INFOROM_POWER);
	$inforom_hash{'PWRInforom'} = handle_error($return,$value);
	
	return \%inforom_hash;
}
sub get_device_ecc{
	my %current_device = %{(shift)};
	my %ecc_hash;
	my ($return,$value,$value1) = nvmlDeviceGetEccMode($current_device{'deviceHandle'});
	$ecc_hash{'currentECCMode'} = handle_error($return,$value);
	$ecc_hash{'pendingECCMode'} = handle_error($return,$value1);
	
	($return,$value) = nvmlDeviceGetMemoryErrorCounter($current_device{'deviceHandle'},
		$NVML_MEMORY_ERROR_TYPE_CORRECTED,$NVML_AGGREGATE_ECC,$NVML_MEMORY_LOCATION_DEVICE_MEMORY);
	$ecc_hash{'ECCMemAggSgl'} = handle_error($return,$value);
	
	($return,$value) = nvmlDeviceGetMemoryErrorCounter($current_device{'deviceHandle'},
		$NVML_MEMORY_ERROR_TYPE_UNCORRECTED,$NVML_AGGREGATE_ECC,$NVML_MEMORY_LOCATION_DEVICE_MEMORY);
	$ecc_hash{'ECCMemAggDble'} = handle_error($return,$value);
	
	($return,$value) = nvmlDeviceGetMemoryErrorCounter($current_device{'deviceHandle'},
		$NVML_MEMORY_ERROR_TYPE_CORRECTED,$NVML_AGGREGATE_ECC,$NVML_MEMORY_LOCATION_L1_CACHE);
	$ecc_hash{'ECCL1AggSgl'} = handle_error($return,$value);
	
	($return,$value) = nvmlDeviceGetMemoryErrorCounter($current_device{'deviceHandle'},
		$NVML_MEMORY_ERROR_TYPE_UNCORRECTED,$NVML_AGGREGATE_ECC,$NVML_MEMORY_LOCATION_L1_CACHE);
	$ecc_hash{'ECCL1AggDble'} = handle_error($return,$value);
	
	($return,$value) = nvmlDeviceGetMemoryErrorCounter($current_device{'deviceHandle'},
		$NVML_MEMORY_ERROR_TYPE_CORRECTED,$NVML_AGGREGATE_ECC,$NVML_MEMORY_LOCATION_L2_CACHE);
	$ecc_hash{'ECCL2AggSgl'} = handle_error($return,$value);
	
	($return,$value) = nvmlDeviceGetMemoryErrorCounter($current_device{'deviceHandle'},
		$NVML_MEMORY_ERROR_TYPE_UNCORRECTED,$NVML_AGGREGATE_ECC,$NVML_MEMORY_LOCATION_L2_CACHE);
	$ecc_hash{'ECCL2AggDble'} = handle_error($return,$value);
	
	($return,$value) = nvmlDeviceGetMemoryErrorCounter($current_device{'deviceHandle'},
		$NVML_MEMORY_ERROR_TYPE_CORRECTED,$NVML_AGGREGATE_ECC,$NVML_MEMORY_LOCATION_REGISTER_FILE);
	$ecc_hash{'ECCRegAggSgl'} = handle_error($return,$value);
	
	($return,$value) = nvmlDeviceGetMemoryErrorCounter($current_device{'deviceHandle'},
		$NVML_MEMORY_ERROR_TYPE_UNCORRECTED,$NVML_AGGREGATE_ECC,$NVML_MEMORY_LOCATION_REGISTER_FILE);
	$ecc_hash{'ECCRegAggDble'} = handle_error($return,$value);
	
	($return,$value) = nvmlDeviceGetMemoryErrorCounter($current_device{'deviceHandle'},
		$NVML_MEMORY_ERROR_TYPE_CORRECTED,$NVML_AGGREGATE_ECC,$NVML_MEMORY_LOCATION_TEXTURE_MEMORY);
	$ecc_hash{'ECCTexAggSgl'} = handle_error($return,$value);
	
	($return,$value) = nvmlDeviceGetMemoryErrorCounter($current_device{'deviceHandle'},
		$NVML_MEMORY_ERROR_TYPE_UNCORRECTED,$NVML_AGGREGATE_ECC,$NVML_MEMORY_LOCATION_TEXTURE_MEMORY);
	$ecc_hash{'ECCTexAggDble'} = handle_error($return,$value);
	
	return \%ecc_hash;
}
sub get_device_power{
	my %current_device = %{(shift)};
	my %power_hash;
	my ($return,$value) = nvmlDeviceGetPowerManagementMode($current_device{'deviceHandle'});
	$power_hash{'PWRMgmtMode'} = handle_error($return,$value);
	if($power_hash{'PWRMgmtMode'} == $NVML_FEATURE_ENABLED){
		($return,$value) = nvmlDeviceGetPowerUsage($current_device{'deviceHandle'});
		$power_hash{'PWRUsage'} = handle_error($return,$value);
		if($return == $NVML_SUCCESS){
			#convert mW to W
			$power_hash{'PWRUsage'} /= 1000;
		}
	}
	return \%power_hash;
}

sub get_persistence_mode{
	my %current_device = %{(shift)};
	my ($return,$value) = nvmlDeviceGetPersistenceMode($current_device{'deviceHandle'});
	return handle_error($return,$value);
}

sub get_inforom_validation{
	my %current_device = %{(shift)};
	my $return = nvmlDeviceValidateInforom($current_device{'deviceHandle'});
	if ($return == $NVML_ERROR_NOT_SUPPORTED){
		$return = 'N/A';
	}
	return $return;
}

sub get_device_memory{
	my %current_device = %{(shift)};
	my $used_memory;
	my ($return,$value) = nvmlDeviceGetMemoryInfo($current_device{'deviceHandle'});
	my $memory_hash = handle_error($return,$value);
	if($return == $NVML_SUCCESS){
		$used_memory = 100 * ($memory_hash->{'used'}) / ($memory_hash->{'total'});
		return $used_memory;
	}
	else{
		return $memory_hash;
	}
}

sub get_device_util{
	my %current_device = %{(shift)};
	my %util_hash;
	my ($return,$value) = nvmlDeviceGetUtilizationRates($current_device{'deviceHandle'});
	my $ret_hash = handle_error($return,$value);
	if($return == $NVML_SUCCESS){
		$util_hash{'gpuUtil'} = $ret_hash->{'gpu'};
		$util_hash{'memUtil'} = $ret_hash->{'memory'};
		return \%util_hash;
	}
	else{
		return $ret_hash;
	}
}

sub get_device_status{
	my $current_ref = shift;
	my %current_device = %$current_ref;
	my ($return, $value) = 0;
	
	($return,$value) = nvmlDeviceGetName($current_device{'deviceHandle'});
	$current_device{'productName'} = (handle_error($return,$value));
	
	($return,$value) = nvmlDeviceGetComputeMode($current_device{'deviceHandle'});
	$current_device{'nvmlDeviceComputeMode'} = (handle_error($return,$value));	
	
	($return,$value) = nvmlDeviceGetFanSpeed($current_device{'deviceHandle'});
	$current_device{'nvmlDeviceFanSpeed'} = (handle_error($return,$value));
	
	($return,$value) = nvmlDeviceGetTemperature($current_device{'deviceHandle'},$NVML_TEMPERATURE_GPU);
	$current_device{'nvmlGpuTemperature'} = (handle_error($return,$value));
		
	($return,$value) = nvmlDeviceGetPciInfo($current_device{'deviceHandle'});
	$current_device{'nvmlDevicePciInfo'} = (handle_error($return,$value));
	
	$current_device{'utilizationRates'} = get_device_util($current_ref);
	
	$return = get_device_clock($current_ref);	
	$current_device{'nvmlClockInfo'} = $return;
	
	$return = get_device_inforom($current_ref);	
	$current_device{'nvmlDeviceInforom'} = $return;
	
	$return = get_device_ecc($current_ref);	
	$current_device{'nvmlDeviceEccInfos'} = $return;
	
	$return = get_device_power($current_ref);	
	$current_device{'nvmlDevicePowerInfos'} = $return;
	
	$return = get_device_memory($current_ref);
	$current_device{'nvmlUsedMemory'} = $return;
	
	$current_device{'persistenceMode'} = get_persistence_mode($current_ref);
	
	$current_device{'inforomValid'} = get_inforom_validation($current_ref);
	
	return \%current_device;
}
###############################################
# Overall device functions 
# They collect functions for a in the current system
###############################################
sub get_all_device_status{
	my $device_id = shift;
	my $device_bus = shift;
	
	my ($return, $handle);
	
	my $count = get_device_count();
	if($count eq "NOK"){
		print "Error: ".$LASTERRORSTRING.".\n";
		exit(3); 
	}
	if($count == 0){
		print "Error: No NVIDIA device found in current system.\n";
		exit(3);
	}
	if($device_bus ne ''){
		($return, $handle) = nvmlDeviceGetHandleByPciBusId($device_bus);
		if($return != $NVML_SUCCESS){
			print "Error: Cannot get handle for device bus ID: ".nvmlErrorString($return)."\n";
			return "NOK";
		}
	}
	else{
		if($device_id != -1){
			($return, $handle) = nvmlDeviceGetHandleByIndex($device_id);
			if($return != $NVML_SUCCESS){
				print "Error: Cannot get handle for device: ".nvmlErrorString($return)."\n";
				return "NOK";
			}
		}
	}
	my %gpu_h;
	my $gpu_ref = \%gpu_h;

	if($device_id != -1){
		$gpu_h{'deviceID'} = $device_id;
	}
	if($device_bus ne ''){
		$gpu_h{'devicePCIBusID'} = $device_bus;
	}
	$gpu_h{'deviceHandle'} = $handle;
	#fetching gpu status			
	$gpu_ref = get_device_status(\%gpu_h);
	push(@DEVICE_LIST,$gpu_ref);
}

#parses the device hashes and collects the perf data (only numeric values)
#into arrays
sub collect_perf_data{
	
	my $sensor_list_ref = shift;
	my @sensor_list = ();
		
	foreach my $device (@DEVICE_LIST){
		#fetch the desired sensors
		if(@$sensor_list_ref){
			@sensor_list = split(/,/, join(',', @$sensor_list_ref));
		}
		else{
			#if no sensor is given via -T, we dump all
			@sensor_list = keys %$device;
		}
		my %dev_perf_data = ();
		my $dev_data_ref = \%dev_perf_data;
		$dev_data_ref = check_hash_for_perf($device,$dev_data_ref,\@sensor_list);
		push(@PERF_DATA,$dev_data_ref);#push device perf data to system array
	}	
}
#checks if the given performance data is in its rangens
sub check_perf_threshold{
	my @warn_list = @{(shift)};
	my @crit_list = @{(shift)};
	my @status_level = ("OK");
	my @warn_level = ();#warning sensors
	my @crit_level = ();#crit sensors
	
	my $i = 0;
	if(@warn_list){
		@warn_list = split(/,/, join(',', @warn_list));
		for ($i = 0; $i < @warn_list; $i++){
			#everything, except that values that should stay default, get new values
			#e.g. -w d,15,60 changes the warning level for sensor 2 and 3 but not for 1
			if($warn_list[$i] ne 'd'){
				switch($i){
					case 0 {$PERF_THRESHOLDS{'nvmlGpuTemperature'}[0] = $warn_list[$i]};
					case 1 {$PERF_THRESHOLDS{'nvmlUsedMemory'}[0] = $warn_list[$i]};
					case 2 {$PERF_THRESHOLDS{'nvmlDeviceFanSpeed'}[0] = $warn_list[$i]};
					case 3 {$PERF_THRESHOLDS{'ECCMemAggSgl'}[0] = $warn_list[$i]};
					case 4 {$PERF_THRESHOLDS{'ECCL1AggSgl'}[0] = $warn_list[$i]};
					case 5 {$PERF_THRESHOLDS{'ECCL2AggSgl'}[0] = $warn_list[$i]};
					case 6 {$PERF_THRESHOLDS{'ECCRegAggSgl'}[0] = $warn_list[$i]};
					case 7 {$PERF_THRESHOLDS{'ECCTexAggSgl'}[0] = $warn_list[$i]};
					case 8 {$PERF_THRESHOLDS{'PWRUsage'}[0] = $warn_list[$i]};
					case 9 {$PERF_THRESHOLDS{'gpuUtil'}[0] = $warn_list[$i]};
					case 10 {$PERF_THRESHOLDS{'memUtil'}[0] = $warn_list[$i]};
				}
			}		
		}			
	}
	if(@crit_list){
		@crit_list = split(/,/, join(',', @crit_list));
		for ($i = 0; $i < @crit_list; $i++){
			if($crit_list[$i] ne 'd'){
				switch($i){
					case 0 {$PERF_THRESHOLDS{'nvmlGpuTemperature'}[1] = $crit_list[$i]};
					case 1 {$PERF_THRESHOLDS{'nvmlUsedMemory'}[1] = $crit_list[$i]};
					case 2 {$PERF_THRESHOLDS{'nvmlDeviceFanSpeed'}[1] = $crit_list[$i]};
					case 3 {$PERF_THRESHOLDS{'ECCMemAggSgl'}[1] = $crit_list[$i]};
					case 4 {$PERF_THRESHOLDS{'ECCL1AggSgl'}[1] = $crit_list[$i]};
					case 5 {$PERF_THRESHOLDS{'ECCL2AggSgl'}[1] = $crit_list[$i]};
					case 6 {$PERF_THRESHOLDS{'ECCRegAggSgl'}[1] = $crit_list[$i]};
					case 7 {$PERF_THRESHOLDS{'ECCTexAggSgl'}[1] = $crit_list[$i]};
					case 8 {$PERF_THRESHOLDS{'PWRUsage'}[1] = $crit_list[$i]};
					case 9 {$PERF_THRESHOLDS{'gpuUtil'}[1] = $crit_list[$i]};
					case 10 {$PERF_THRESHOLDS{'memUtil'}[1] = $crit_list[$i]};
				}
			}		
		}			
	}
	#fetch the perfdata of the gpu
	my $perf_hash = $PERF_DATA[0];
	
	foreach my $k (keys %$perf_hash){
		if(exists $PERF_THRESHOLDS{$k}){
			#warning level
			if($perf_hash->{$k} >= $PERF_THRESHOLDS{$k}[0]){
				$status_level[0] = "Warning";
				push(@warn_level,$k);
			}
			#critival level
			if($perf_hash->{$k} >= $PERF_THRESHOLDS{$k}[1]){
				$status_level[0] = "Critical";
				pop(@warn_level);#as it is critical, remove it from warning
				push(@crit_level,$k);
			}
		}		
	}
	push(@status_level,\@warn_level);
	push(@status_level,\@crit_level);
	
	return \@status_level;
}

#check the discrete sensors, they just trigger a certain status level
sub check_discrete_sensors{
	my @status_level = @{(shift)};#the current status list
	#fetch the gpu data
	my $dev_data_ref = $DEVICE_LIST[0];
	#check for double ecc errors
	foreach my $k (keys %{$dev_data_ref->{'nvmlDeviceEccInfos'}}){
		if($k =~ m/.*Dble/){
			if($dev_data_ref->{'nvmlDeviceEccInfos'}->{$k} > 0){
				$status_level[0] = "Critical";
				#add key to critical array
				push($status_level[2],$k);
			}
		}
	}
	#check if persistence mode is available and enabled
	if(exists($dev_data_ref->{'persistenceMode'}) &&
	$dev_data_ref->{'persistenceMode'} == $NVML_FEATURE_DISABLED){
		#ensure to not drop an already Critical level
		if($status_level[0] eq 'OK'){
			$status_level[0] = "Warning";
		}
		push($status_level[1],'persistenceMode');
	}
	#check if inforom checksum is valid
	if(exists($dev_data_ref->{'inforomValid'}) &&
	$dev_data_ref->{'inforomValid'} == $NVML_ERROR_CORRUPTED_INFOROM){
		#ensure to not drop an already Critical level
		if($status_level[0] eq 'OK'){
			$status_level[0] = "Critical";
		}
		push($status_level[2],'inforomValid');
	}
	return \@status_level;
}

###############################################
# Main function
# Command line processing and device status collection
###############################################
MAIN: {
	my ($nvml_host,$config_file,$show_na,$show_default) = '';
	my @sensor_list = ();#query a specific sensor
	my @warn_threshold = ();#change thresholds for performance data
	my @crit_threshold = ();
	my $verbosity = 0;
	my $device_id = -1;#the desired gpu device to query
	my $device_bus = '';#device bus information
	
	#Check for nvml installation
	my $result = '';
	if(($result = check_nvml_setup()) ne "OK"){
		print "Debug: Nvml setup check failed.\n";
		print "Error: ".$LASTERRORSTRING.".\n";
		exit(3);
	}
	#Initialize nvml library
	$result = nvmlInit();
	if($result != $NVML_SUCCESS){
		print "Debug: NVML initialization failed.\n";
		print "Error: ".nvmlErrorString($result).".\n";
		exit(3);
	}
	
	#Parse command line options
	if( !(Getopt::Long::GetOptions(
		'h|help'	=>
		sub{print get_version();
				print  "\n";
				print get_usage();
				print "\n";
				print get_help()."\n";
				exit(0);
		},
		'V|version'	=>
		sub{print get_version()."\n";
				exit(0);
		},
		'd|device=i'	=> \$device_id,
		'db|device-bus=s'	=> \$device_bus,
		'v|verbosity'	=>	\$verbosity,
		'vv'			=> sub{$verbosity=2},
		'vvv'			=> sub{$verbosity=3},
		'T|sensors=s' => \@sensor_list,
		'w|warning=s' => \@warn_threshold,
		'c|critical=s' => \@crit_threshold,
		'show-na'	=> \$show_na,
	))){
		print get_usage()."\n";
		exit(1);
	}
	if(@ARGV){
		#we don't want any unused command line arguments
		print get_usage()."\n";
		exit(3);
	}

	if(($result = get_driver_version()) eq "NOK"){
		print "Error: driver version - ".$LASTERRORSTRING.".\n";
		exit(3);
	}
	
	#the device ID is not present 
	if($device_id == -1 && $device_bus eq ''){
		print "Error: Valid PCI bus string or device ID is required.\n";
		print get_usage()."\n";
		exit(3);
	}
	
	#Collect the informations about the device in the system
	if( (get_all_device_status($device_id,$device_bus)) eq "NOK"){
		print "Ensure to use a valid device id or device bus string.\n";
		exit(3);
	}
	
	#TODO Is the sensor list only for performance data valid?
	collect_perf_data(\@sensor_list);
	my $status_level;
	$status_level = check_perf_threshold(\@warn_threshold,\@crit_threshold);
	$status_level = check_discrete_sensors($status_level);
	#check return values of threshold and discrete sensor function
	if($status_level->[0] eq "Critical"){
		$EXIT_CODE = 2;#Critical
	}
	if($status_level->[0] eq "Warning"){
		$EXIT_CODE = 1;#Warning
	}
	print $status_level->[0]." - ".$DEVICE_LIST[0]->{'productName'}." ";
	print get_status_string("Critical",$status_level,$verbosity);
	print get_status_string("Warning",$status_level,$verbosity);
	print "|";
	print get_status_string("Performance",$PERF_DATA[0]);
	print "\n".get_verbose_string($verbosity,$DEVICE_LIST[0],$show_na);

	#shutdown nvml library
	$result = nvmlShutdown();
	if($result != $NVML_SUCCESS){
		print "Debug: NVML shutdown failed.\n";
		print "Error: ".nvmlErrorString($result).".\n";
		exit(3);
	}
	exit($EXIT_CODE);	
}

__END__

=head1 NAME

check_gpu_sensor - A NVIDIA nvml plugin to check gpu sensors.

=head1 SYNOPSIS

Example:

	$ ./check_gpu_sensor -db '0000:83:00.0'
	OK - Tesla K20c |ECCL2AggSgl=0;1;2; ECCTexAggSgl=0;1;2; PWRUsage=31.43;150;200;
	ECCRegAggSgl=0;1;2; SMClock=705 ECCL1AggSgl=0;1;2; nvmlUsedMemory=0.24;95;99;
	nvmlDeviceFanSpeed=30;80;95; memClock=2600 gpu=25 memory=1 graphicsClock=705
	nvmlGpuTemperature=36;85;100; ECCMemAggSgl=0;1;2;
	
=head1 DESCRIPTION

=head1 METHODS

=head2 get_device_power

Retreives the device's power usage in watts. Calls nvmlDeviceGetPowerUsage and
converts the return value (milliwatts) to watts. To set a power level with
nvidia-smi use (administrator privileges reqired):

	$ sudo nvidia-smi -i ID -pl POWER_LIMIT
	
Limits must be between Min and Max power limit. The limit defines the upper
bound at which the power managment algorithm starts in. To get the supported
power limits execute:

	$ nvidia-smi -i 0 -q -d POWER
	
Performance threasholds set via the plugin are independent from the
nvidia-smi one's.'

=head2 get_persistence_mode

Gets the device's persistence mode setting (due to nvidia-smi documentation
only on Linux available. If the setting is available it later on checks if
the mode is enabled. As it more convenient to use the persistence mode a
Warning status is triggered if the persistence mode is not enabled. Enable
the mode with:

	$ sudo nvidia-smi -i ID -pm 1

=head2 get_inforom_validation

Reads the inforom from the flash file and verifys the checksum. If the
inforom is corrupted the sensor is treated as a discrete sensor and
a critical status is returned.

=head1 DIAGNOSTICS